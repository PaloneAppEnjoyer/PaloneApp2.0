package com.palone.paloneapp.utils.timetableDataResponseToListOfTimetableDataParser

import com.palone.paloneapp.timetable.data.models.TimetableData
import com.palone.paloneapp.timetable.data.models.TimetableDataEntry
import com.palone.paloneapp.timetable.data.models.TimetableDay
import com.palone.paloneapp.timetable.data.models.TimetableLessons
import com.palone.paloneapp.timetable.data.models.responses.timetable_autogenerated.TimetableRemoteDataResponse
import com.palone.paloneapp.timetable.data.models.timetableVariables.*
import com.palone.paloneapp.utils.between

class TimetableDataResponseToListOfTimetableDataParserImpl :
    TimetableDataResponseToListOfTimetableDataParserInterface {
    override fun getTimetableDataResponseParsedToListOfTimetableData(dataResponse: TimetableRemoteDataResponse): List<TimetableData> {
        val timetableData = mutableListOf<TimetableData>()
        val lessonsSorted = mutableListOf<Map<String, TimetableDataEntry>>()
        val subjects = mutableListOf<Subject>()
        val mapTeachers = mutableListOf<Teacher>()
        val mapClasses = mutableListOf<SchoolClass>()
        val mapDays = mutableListOf<Day>()
        val mapDaysdefs = mutableListOf<DaysDef>()
        val mapCards = mutableListOf<Card>()
        val mapClassrooms = mutableListOf<ClassRoom>()
        val mapGroups = mutableListOf<Group>()
        val lessonsList = mutableListOf<Lesson>()
        dataResponse.response.dbiAccessorRes.tables.forEach { it1 ->
            if (it1.data_rows.isNotEmpty() && it1.id == "subjects")
                it1.data_rows.forEach { subjects.add(Subject(it.id, it.name, it.short)) }
        }
        dataResponse.response.dbiAccessorRes.tables.forEach { it1 ->
            if (it1.data_rows.isNotEmpty() && it1.id == "teachers")
                it1.data_rows.forEach { mapTeachers.add(Teacher(it.id, it.short)) }
        }
        dataResponse.response.dbiAccessorRes.tables.forEach { it1 ->
            if (it1.data_rows.isNotEmpty() && it1.id == "classes")
                it1.data_rows.forEach {
                    mapClasses.add(
                        SchoolClass(
                            it.id, it.name.replace("(", "")
                                .replace(")", "")
                                .replace("{", "")
                                .replace("}", "")
                                .replace(" ", "")
                        )
                    )
                }
        }
        dataResponse.response.dbiAccessorRes.tables.forEach { it1 ->
            if (it1.data_rows.isNotEmpty() && it1.id == "days")
                it1.data_rows.forEach { mapDays.add(Day(it.id, it.short)) }
        }
        dataResponse.response.dbiAccessorRes.tables.forEach { it1 ->
            if (it1.data_rows.isNotEmpty() && it1.id == "daysdefs")
                it1.data_rows.forEach {
                    mapDaysdefs.add(DaysDef(it.id, it.short, it.vals))
                }
        }
        dataResponse.response.dbiAccessorRes.tables.forEach { it1 ->
            if (it1.data_rows.isNotEmpty() && it1.id == "classrooms")
                it1.data_rows.forEach { mapClassrooms.add(ClassRoom(it.id, it.short)) }
        }
        dataResponse.response.dbiAccessorRes.tables.forEach { it1 ->
            if (it1.data_rows.isNotEmpty() && it1.id == "groups")
                it1.data_rows.forEach {
                    mapGroups.add(
                        Group(
                            it.id,
                            it.name,
                            mapClasses.find { it2 -> it2.id == it.classid } ?: SchoolClass(
                                "9999",
                                "Brak klasy"
                            ), divisionId = it.divisionid
                        )
                    )
                }
        }
        dataResponse.response.dbiAccessorRes.tables.forEach { it1 ->
            if (it1.data_rows.isNotEmpty() && it1.id == "lessons")
                it1.data_rows.forEach {
                    if (it.id.isNotEmpty()) {
                        lessonsList.add(
                            Lesson(
                                it.id,
                                subjects.find { it2 -> it2.id == it.subjectid } ?: Subject(
                                    "9999",
                                    "Brak przedmiotu",
                                    "Brak Przedniotu"
                                ),
                                mapTeachers.filter { it2 -> it.teacherids.contains(it2.id) },
                                mapGroups.filter { it2 -> it.groupids.contains(it2.id) },
                                mapClasses.filter { it2 -> it.classids.contains(it2.id) },
                                mapClassrooms.filter { it2 ->
                                    if (!it.classroomidss.isNullOrEmpty()) it.classroomidss[0].contains(
                                        it2.id
                                    ) else false
                                },
                                it.durationperiods
                            )
                        )
                    }
                }

        }
        dataResponse.response.dbiAccessorRes.tables.forEach { it1 ->
            if (it1.data_rows.isNotEmpty() && it1.id == "cards") {
                it1.data_rows.forEach {
                    mapCards.add(
                        Card(
                            it.id,
                            lessonsList.find { it2 -> it.lessonid == it2.id } ?: Lesson(
                                "9999",
                                Subject(
                                    "9999",
                                    "Brak przedmiotu",
                                    "Brak Przedniotu"
                                ),
                                listOf(Teacher("9999", "Brak danych")),
                                listOf(
                                    Group(
                                        "9999",
                                        "Brak danych",
                                        SchoolClass("9999", "Brak danych"),
                                        "9999"
                                    )
                                ),
                                listOf(SchoolClass("9999", "Brak danych")),
                                listOf(ClassRoom("9999", "Brak danych")),
                                9999
                            ),
                            if (it.period != "") it.period.toInt() else 9999,
                            mapDaysdefs.find { it2 -> it2.values.contains(it.days) } ?: DaysDef(
                                "9999", "Brak danych",
                                listOf("Brak danych")
                            ),
                            mapClassrooms.filter { it2 ->
                                if (it.classroomids.isNotEmpty()) it.classroomids.contains(
                                    it2.id
                                ) else false
                            }

                        )
                    )
                }
            }
        }
        val allSchoolClasses = mapClasses.distinct()
        allSchoolClasses.forEach { parentSchoolClass ->
            mapCards.filter { it.lesson.group.any { it2 -> parentSchoolClass == it2.schoolClass } }
                .forEach { it3 ->
                    if (it3.classRooms.size == 1) {
                        val classesInGroups = mutableListOf<String>()
                        it3.lesson.schoolClass.forEach { it4 -> classesInGroups.add(it4.name) }
                        lessonsSorted.add(
                            mapOf(
                                Pair(
                                    parentSchoolClass.name,
                                    TimetableDataEntry(
                                        it3.lesson.subject.shortName,//TODO Test
                                        it3.lesson.subject.name,
                                        it3.classRooms[0].shortName,
                                        it3.lesson.teacher[0].name,
                                        classesInGroups.toList(),
                                        it3.lesson.durationPeriod,
                                        it3.day.shortName,
                                        it3.period,
                                        it3.lesson.durationPeriod + it3.period - 1,
                                        it3.lesson.group.find { it4 -> it4.schoolClass == parentSchoolClass }?.name
                                            ?: "Brak danych",
                                        it3.day.id.replace("*", "").toInt()
                                    )
                                )
                            )
                        )
                    }
                }
        }



        allSchoolClasses.forEach { className ->
            val mut = mutableListOf<TimetableDataEntry>()
            lessonsSorted.forEach { it2 ->
                it2.filter { it.key == className.name }.forEach {
                    mut.add(it.value)
                }
            }

            val sortByDay: MutableList<TimetableDay> = mutableListOf()

            for (s in listOf("Pn", "Wt", "Åšr", "Czw", "Pi")) {
                val sortByLessonNumber: MutableList<TimetableLessons> = mutableListOf()
                for (i in 0..10) {
                    sortByLessonNumber.add(TimetableLessons(i, mut.filter { it2 ->
                        i.between(
                            it2.lessonFrom,
                            it2.lessonTo
                        ) && it2.dayName == s
                    }))
                }
                sortByDay.add(TimetableDay(s, sortByLessonNumber.toList()))
            }

            timetableData.add(
                TimetableData(
                    className = className.name,
                    day = sortByDay
                )
            )
        }
        return timetableData
    }

}